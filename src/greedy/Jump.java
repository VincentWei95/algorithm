package greedy;

/**
 * 45.跳跃游戏2
 *
 * 给你一个非负整数数组nums ，你最初位于数组的第一个位置。
 *
 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
 *
 * 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
 *
 * 假设你总是可以到达数组的最后一个位置。
 *
 * 示例 1:
 *
 * 输入: nums = [2,3,1,1,4]
 * 输出: 2
 * 解释: 跳到最后一个位置的最小跳跃数是 2。
 *     从下标为 0 跳到下标为 1 的位置，跳1步，然后跳3步到达数组的最后一个位置。
 *
 * 示例 2:
 *
 * 输入: nums = [2,3,0,1,4]
 * 输出: 2
 */
public class Jump {

    /**
     * 思路：
     * 本题和{@link CanJump}思路是相似的，还是要看最大覆盖范围。要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？
     *
     * 贪心的思路：
     * 局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一
     * 整体最优：一步尽可能多走，从而达到最小步数
     *
     * 思路虽然是这样，但在写代码的时候还不能真的就能跳多远就多远，那样就不知道下一步最远能跳到哪里了
     *
     * 所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖到了终点，得到的就是最小的步数。
     *
     * 这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步的最大覆盖
     *
     * 如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖番位覆盖了终点
     *
     * 下标：0  1  2  3  4
     *      2  3  1  1  4
     *      ------
     *      第一步可覆盖范围
     *         ----------
     *         第二步可覆盖范围，覆盖到了终点
     *
     * 能覆盖到终点，不管怎么跳，反正一定可以跳到
     */
    public int jump(int[] nums) {
        if (nums == null || nums.length == 0 || nums.length == 1) return 0;

        int count = 0; // 记录跳跃的次数
        int curDistance = 0; // 当前的覆盖最大区域
        int maxDistance = 0; // 最大的覆盖区域
        for (int i = 0; i < nums.length; i++) {
            // 可覆盖区域内更新最大的覆盖区域
            maxDistance = Math.max(i + nums[i], maxDistance);
            // 说明当前一步，再跳一步就到达终点
            if (maxDistance >= nums.length - 1) {
                count++;
                break;
            }
            // 走到当前覆盖的最大区域时，更新下一步可达的最大区域
            if (i == curDistance) {
                curDistance = maxDistance;
                count++;
            }
        }
        return count;
    }
}
