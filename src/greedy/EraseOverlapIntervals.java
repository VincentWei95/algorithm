package greedy;

import java.util.Arrays;
import java.util.Comparator;

/**
 * 435.无重叠区间
 *
 * 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
 *
 * 注意:
 *
 * 可以认为区间的终点总是大于它的起点。
 * 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
 *
 * 示例 1:
 *
 * 输入: [ [1,2], [2,3], [3,4], [1,3] ]
 * 输出: 1
 *
 * 解释: 移除 [1,3] 后，剩下的区间没有重叠。
 *
 * 示例 2:
 *
 * 输入: [ [1,2], [1,2], [1,2] ]
 * 输出: 2
 *
 * 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
 *
 * 示例 3:
 *
 * 输入: [ [1,2], [2,3] ]
 * 输出: 0
 *
 * 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
 */
public class EraseOverlapIntervals {

    /**
     * 思路：
     * 看到题目就会认为需要排序，但究竟是按照右边界排序，还是按照左边界排序呢？这其实是一个难点
     * 按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的
     * 按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历
     *
     * 题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！
     *
     * 如果按照右边界排序，从左向右记录非交叉区间的个数，最有用 区间总数 - 非交叉区间个数 就是需要移除的区间个数了
     * 此问题就是要求非交叉区间的最大个数
     *
     * 右边界排序之后
     * 局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉
     * 全局最优：选取最多的非交叉区间
     * 局部最优推出全局最优，试试贪心！
     *
     * 记录非交叉区间的个数还是有技巧的：
     *
     *      ----1-----
     *               |
     *  ---------2--------
     *               |
     *        ----------3---------
     *               |
     *               |        --------4--------
     *               |                        |
     *               |  ----------5---------------
     *                                        |
     *                                        |  ------6------
     *                                        |
     * 区间 1，2，3，4，5，6 都按照右边界排好序
     * 每次取非交叉区间的时候，都是右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置
     * 接下来就是找大于区间1结束位置的区间，是从区间4开始。为什么不从区间5开始？要记得是按照右边界排序的。
     * 区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是三个。
     * 总共区间个数为6，减去非交叉区间的个数3，移除区间的最小数量就是3
     *
     * T:O(nlogn)，有一个快排
     * S:O(1)
     *
     * 题目难点总结：
     * 1、看到题目感觉需要排序，但究竟怎么排序，按左边界还是右边界排序
     * 2、排序完之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了
     * 3、直接求重复的区间是复杂的，转而求最大非重复区间个数
     * 4、求最大非重复区间个数时，需要一个分割点来做标记
     * 四个难点都不好想，但任何一个没想到位，这道题就解不了
     */
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) return 0;

        // 按区间右边界从小到大排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Integer.compare(o1[1], o2[1]);
            }
        });

        int count = 1; // 记录非交叉区间个数
        int end = intervals[0][1]; // 记录区间分割点
        for (int i = 1; i < intervals.length; i++) {
            if (end <= intervals[i][0]) {
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.length - count;
    }

    /**
     * 本题和{@link FindMinArrowShots}非常像，弓箭的数量就相当于是非交叉区间的数量，
     * 只要把解题的算法判断修改为 >=，然后用 总区间数 - 弓箭数量 就是要移除的区间数量了
     */
    public int eraseOverlapIntervals2(int[][] intervals) {
        if (intervals.length == 0) return 0;

        // 按右边界从小到大排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Integer.compare(o1[1], o2[1]);
            }
        });

        int count = 1; // 至少需要一支箭
        for (int i = 1; i < intervals.length; i++) {
            // 注意这里是 >=，两个气球挨在一起不重叠也可以射爆
            // 当前气球的起始位置 >= 上一个气球的结束位置
            // 气球 i 和 气球 i-1 不挨着
            if (intervals[i][0] >= intervals[i - 1][1]) {
                count++;
            } else {
                // 气球 i 和 气球 i-1 挨着
                intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1]);
            }
        }
        return intervals.length - count;
    }
}
