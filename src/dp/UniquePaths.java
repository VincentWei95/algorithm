package dp;

/**
 * 62.不同路径
 *
 * 一个机器人位于一个 m x n网格的左上角 （起始点在下图中标记为 “Start” ）。
 *
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
 *
 * 问总共有多少条不同的路径？
 * ---------------------------------------
 * ｜start｜   ｜   ｜   ｜   ｜   ｜      ｜
 * ---------------------------------------
 * ｜     ｜   ｜   ｜   ｜   ｜   ｜      ｜
 * ---------------------------------------
 * ｜     ｜   ｜   ｜   ｜   ｜   ｜Finish｜
 *  -------------------------------------
 *
 * 示例 1：
 *
 * 输入：m = 3, n = 7
 * 输出：28
 *
 * 示例 2：
 *
 * 输入：m = 3, n = 2
 * 输出：3
 * 解释：
 * 从左上角开始，总共有 3 条路径可以到达右下角。
 * 1. 向右 -> 向下 -> 向下
 * 2. 向下 -> 向下 -> 向右
 * 3. 向下 -> 向右 -> 向下
 *
 * 示例 3：
 *
 * 输入：m = 7, n = 3
 * 输出：28
 *
 * 示例 4：
 *
 * 输入：m = 3, n = 3
 * 输出：6
 */
public class UniquePaths {

    /**
     * 机器人从位置 (0, 0) 出发，到终点 (m-1, n-1)
     *
     * 1、确定 dp 数组及下标的含义
     * dp[i][j]：表示从 (0, 0) 出发，到 (i, j) 有 dp[i][j] 条不同的路径
     *
     * 2、确定递推公式
     * 想要求 dp[i][j]，只能有两个方向来推导出来，即 dp[i-1][j] 和 dp[i][j-1]
     * 根据 dp 数组的定义，dp[i-1][j] 是从 (0, 0) 到 (i-1, j) 有几条路径，dp[i][j-1] 同理
     * 所以，dp[i][j] = dp[i-1][j] + dp[i][j-1]，因为 dp[i][j] 只有这两个方向过来
     *
     * 3、确定 dp 数组初始化
     * 首先 dp[i][0] 一定都是1，因为从 (0, 0) 位置到 (i, 0) 位置的路径只有一条，dp[0][j] 同理
     * 所以初始化代码为：
     * for (int i = 0; i < m; i++) dp[i][0] = 1;
     * for (int j = 0; j < n; j++) dp[0][j] = 1;
     *
     * 4、确定遍历顺序
     * 根据递推公式 dp[i][j] = dp[i-1][j] + dp[i][j-1]，dp[i][j] 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了
     * 这样就可以保证推导 dp[i][j] 的时候，dp[i-1][j] 和 dp[i][j-1] 一定是有数值的
     *
     * 5、举例推导 dp 数组
     * 假设 m=3, n=7，dp[i][j] 推导数值如下：
     * ------------------------------------------------
     * ｜  1  ｜  1  ｜  1  ｜  1  ｜  1  ｜  1  ｜  1  ｜
     * ------------------------------------------------
     * ｜  1  ｜  2  ｜  3  ｜  4  ｜  5  ｜  6  ｜  7  ｜
     * ------------------------------------------------
     * ｜  1  ｜  3  ｜  6  ｜ 10  ｜  15 ｜  21 ｜ 28  ｜
     *  -----------------------------------------------
     *
     * T:O(m*n)
     * S:O(m*n)
     */
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
