# 什么是动态规划

动态规划（Dynamic Programming，简称 dp），如果某一问题有很多重叠子问题，使用动态规划是最有效的。

**动态规划中每一个状态一定是由上一个状态推导出来的**，这一点就区分于贪心，贪心没有状态推导，而是从局部最优推导出全局最优。

例如：

有 n 件物品和一个最多能背重量为 w 的背包，第 i 件物品的重量是 weight[i]，得到的价值是 value[i]。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

动态规划中 dp[j] 是有 dp[j - weight[i]] 推导出来的，然后取 max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心算法，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。

# 动态规划的解题步骤

做动态规划题目的时候，很多人会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢，就开始写代码，甚至把题目AC之后，都不太清楚 dp[i] 表示的是什么。

这就是一种朦胧状态，然后就把题目给过了，遇到稍稍难一点的可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中。

**状态转移公式（递推公式）是很重要，但动态规划不仅仅只有递推公式**。

对于动态规划问题，可以拆解为五个步骤，这五个步骤都搞清楚了，才能说把动态规划真的掌握了！

- **确定 dp 数组（dp table）以及下标的含义**

- **确定递推公式**

- **dp 数组如何初始化**

- **确定遍历顺序**

- **举例推导 dp 数组**

或许有人会想为什么要先确定递推公式，然后再考虑初始化？

**因为一些情况是递推公式决定了 dp 数组要如何初始化！**

刷过动态规划题目的人可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。其实确定递推公式仅仅是解题的一步而已！

有些人知道递归公式，但搞不清楚 dp 数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。

# 动态规划应该如何 debug

很多人写动态规划的题目，会看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉； 一旦要是没通过，就怎么改都通过不了，对 dp 数组的初始化，递推公式，处于一种黑盒的理解状态。

写动态规划题目，代码出问题很正常！

**找问题最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！**

做动态规划的题目，不清楚 dp 数组的含义，不懂为什么这么初始化，递推公式背下来，遍历顺序靠习惯就这么写，靠感觉写一写改一改。这是一个很不好的习惯！

**做动态规划的题目，写代码之前一定要把状态转移在 dp 数组上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印 dp 数组，看看是不是和自己预先推导的哪里不一样。
如果打印出来和自己预先模拟推导是一样的，那么就是自己的递推公式、初始化或者遍历顺序有问题了。 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

这才是一个完整的思考过程，而不是一旦代码出问题，就好无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了。

做动态规划的题目如果没通过，可以先思考这三个问题：

- 这道题目我举例推导状态转移公式了吗？

- 打印 dp 数组了吗？

- 打印出来的 dp 数组和我想的一样吗？

如果这三个问题都做到了，基本上这道题目也就解决了，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历 dp 数组的顺序。

