# 回溯基础理论

## 什么是回溯法

回溯法也可以叫回溯搜索法，它是一种搜索方式。回溯是递归的副产品，**只要有递归就会有回溯**。回溯也是一个函数。

## 回溯法的效率

回溯法并不是什么高效的算法，因为 **回溯的本质是穷举**，穷举所有可能，然后选出我们想要的答案。

如果想让回溯法高效一些，可以加一些剪枝操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它？因为没得选，一些问题能暴力搜出来就不错了，撑死了在剪枝一下，还没有更高效的解法。

## 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合

- 切割问题：一个字符串按一定规则有几种切割方式

- 子集问题：一个N个数的集合里有多少符合条件的子集

- 排列问题：N个数按一定规则全排列，有几种排列方式

- 棋盘问题：N皇后，解数独等等

**组合与排列的区别是，组合是不强调元素顺序的，排列是强调元素顺序的，组合无序，排列有序**。

例如：[1, 2] 和 [2, 1] 在组合上，就是一个集合，因为不强调顺序；而排列的话这就是两个集合。

## 如何理解回溯法

**回溯法解决的问题都可以抽象为树形结构**。

因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一颗 **高度有限的N叉树**。

## 回溯法模板

1、确定递归函数参数和返回值

回溯算法中函数返回值一般为void。

回溯算法的参数不像二叉树递归时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

伪代码如下：

```java
void backtracking(参数)
```

2、确定递归函数终止条件

回溯法是树形结构，那递归遍历树就要有终止条件。

在树中，一般来说搜索到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

所以回溯函数的终止条件伪代码如下：

```java
if (终止条件) {
    存放结果
    return
}
```

3、确定递归单层逻辑

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

        -------------------for循环，横向遍历--------------->
|
|   第一层                         集合size:4
|递                          /    |     |      \
|归                         /     |     |       \
|纵                        /      |     |        \
|向                       /       |     |         \
|遍 第二层       集合size:3  集合size:2 集合size:1  集合size:0
|历                /  |  \     |    |     |
|                 /   |   \    |    |     |
|   第三层       集合 集合 集合  集合 集合   集合

注意图中，特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过伪代码如下：

```java
for (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
    处理节点
    backtracking(路径，选择列表） // 递归
    回溯，撤销处理结果
}
```

for 循环就是遍历集合区间，可以理解一个节点有多个孩子，这个 for 循环就执行多少次。

for 循环可以理解为横向遍历，backtracking() 就是递归纵向遍历，这样就把这棵树全遍历完了。**一般来说，搜索叶子节点就是找的其中一个结果了**。

分析完过程，回溯算法模板如下：

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果
        return
    }

    for (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
        处理节点
        backtracking(路径，选择列表) // 递归
        回溯，撤销处理结果
    }
}
```

# 回溯剪枝

剪枝操作一般都会在 for 循环处理。

**剪枝精髓是：for 循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的 k 个元素了，就没有必要搜索了**。

# 回溯去重问题

一般遇到去重问题时，在进入递归函数之前，都需要先数组进行排序。

在 for 循环时，如果当前元素和上一个元素相同，则需要去重复。模板如下：

```java
public List<List<Integer>> test(int[] nums) {
    Arrays.sort(nums); // 递归前需要进行排序，否则无法处理重复问题
    backtracking(nums, 0);
}

void backtracking(int[] nums, int startIndex) {
    // 终止条件处理

    // startIndex 用于缩小范围
    for (int i = startIndex; i < nums.lenght; i++) {
        if (i > startIndex && nums[i] == nums[i - 1]) continue; // 去重，需要注意这里的判断 i > startIndex
        // 处理节点
        backtracking(nums, i + 1);
        // 回溯，撤销节点
    }
}
```

# 回溯的组合、子集、排列问题在收集节点时的区别

一般来说：**组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果**。

# 性能分析

1、子集问题分析

时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为 O(2^n)
空间复杂度：O(n)，递归深度为 n，所以系统栈所用空间为 O(n)，每一层递归所用的空间都是常数级别，注意代码里的 result 和 path 都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为 O(n)

2、排列问题分析

时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为 n，第二层每一个分支都延伸了 n-1 个分支，再往下又是 n-2 个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!
空间复杂度：O(n)，和子集问题同理

3、组合问题分析

时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度
空间复杂度：O(n)，和子集问题同理